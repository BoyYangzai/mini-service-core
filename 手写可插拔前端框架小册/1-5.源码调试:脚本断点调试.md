#### 该小节主要知识点：

-   为什么需要调试 <span style="color: #ff502c;background-color: #fff5f5">bin 脚本</span>？
-   如何快速<span style="color: #ff502c;background-color: #fff5f5">上手</span>调试 bin 脚本
-   什么是 <span style="color: #ff502c;background-color: #fff5f5">sourcemap</span> ？调试中为什么需要 sourcemap ？
-   实战：调试 <span style="color: #ff502c;background-color: #fff5f5">Umi 源代码</span>
-   基于调试中的问题，给 Umi 提个 **pr**

### 本小节最终效果：
(这是我手写 mini-umi 时在 **<span style="color: #ff502c;background-color: #fff5f5">Umi 源码</span>** 中打的所有 <span style="color: #ff502c;background-color: #fff5f5">关键断点</span> )
![屏幕录制2022-12-08-07.49.25.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d8a9193b394f9fb6991ae590abb2bf~tplv-k3u1fbpfcp-watermark.image?)

## 1.为什么需要调试 bin 脚本？
你是否有思考过，当你在使用 VueCLI 或 create-react-app 创建的模版项目中使用 <span style="color: #ff502c;background-color: #fff5f5">npm run dev</span> 时，Webpack是如何 从0到1 启动这整个项目的吗？

当你在使用 Vue3+Vite 项目时，Vite dev 命令到底做了什么事情呢？Vite dev 与 Webpack 的 dev 又有什么不一样呢？

除了 Webpack，Vite，更多的还有 <span style="color: #ff502c;background-color: #fff5f5">Nuxt</span>、<span style="color: #ff502c;background-color: #fff5f5">Next</span>、<span style="color: #ff502c;background-color: #fff5f5">Esbuild</span>等框架或工具

除了 dev，还有 <span style="color: #ff502c;background-color: #fff5f5">build</span>、<span style="color: #ff502c;background-color: #fff5f5">lint</span>、<span style="color: #ff502c;background-color: #fff5f5">test</span>等指令

如果你想知道他们工作以及运转的原理，就需要阅读他们的源代码，而通过调试 CLI入 口的 <span style="color: #ff502c;background-color: #fff5f5">bin脚本</span>，就可以看到所有指令 **<span style="color: #ff502c;background-color: #fff5f5">从0到1</span>** 是如何 **<span style="color: #ff502c;background-color: #fff5f5">执行</span>** 的
## 2.如何快速上手调试 bin 脚本
**bin 脚本的调试其实是非常<span style="color: #ff502c;background-color: #fff5f5">简单</span>的，我们来简单盘一下逻辑**

还记得我们在第4小节手写CLI时学过：如果你是一个 Node 侧的命令行工具，当你去执行 <span style="color: #ff502c;background-color: #fff5f5">npm run xxx</span> 时，其实都是去执行了 bin 目录下的脚本文件

而 Node 环境的<span style="color: #ff502c;background-color: #fff5f5">脚本</span>本质上不过是一个 **<span style="color: #ff502c;background-color: #fff5f5">Nodejs 文件</span>**

所以，我们调试 bin 脚本 和调试运行一个 Nodejs 文件又有什么区别呢？

#### 那如何调试一个 Nodejs 文件呢？
接下来我带着大家一步一步尝试：

#### 1.创建我们的调试项目
```
mkdir debugger
code debugger
```
#### 2.创建调试的入口文件
```ts
// debugger.js
const yang = 'yang'

const yangyang = yang + 'yang'

console.log(yangyang+'yang');

```
#### 3.尝试运行
```
node debugger.js 
// yangyangyang
```
运行成功✅

### 接下来开始调试的部分

#### 1.进入vscode调试面板
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/444e66ac5d1d416498804f0c6cab8ccc~tplv-k3u1fbpfcp-watermark.image?)

#### 2.给我们的 debugger.js 文件打一个断点
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ec2eba02c394704a90d3d3c15607a01~tplv-k3u1fbpfcp-watermark.image?)
也可以这样打断点，使用 **debugger** 关键字
```diff
+ debugger;
  const yang = 'yang'
  const yangyang = yang + 'yang'
  console.log(yangyang + 'yang');
```
#### 3.点击运行和调试按钮
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75d3abd9cf794ac5a0b0d420cc649f1c~tplv-k3u1fbpfcp-watermark.image?)

#### 4.这里直接选择 Nodejs 环境
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b000c5e829c446fafd324e41bbc711a~tplv-k3u1fbpfcp-watermark.image?)

这时候你会发现，调试模式已经启动了，成功✅
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a163df3a727240e5b5e4d5884c5567b8~tplv-k3u1fbpfcp-watermark.image?)

#### 当然第4步这里其实还是要说明一下
>4.这里直接选择 Nodejs 环境
你目前所在的工作文件是<span style="color: #ff502c;background-color: #fff5f5">debugger.js</span>，所以当你这里直接选择debugger.js文件之后，等同于vscode帮你<span style="color: #ff502c;background-color: #fff5f5">自动创建</span>了调试的<span style="color: #ff502c;background-color: #fff5f5">配置文件</span>，并把 **<span style="color: #ff502c;background-color: #fff5f5">program</span>** 字段指向了我们的 debugger.js

你可以使用配置文件尝试一下，效果是<span style="color: #ff502c;background-color: #fff5f5">等价</span>的
#### 创建调试配置文件
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/287eb96e40254415ae66b914e834b71f~tplv-k3u1fbpfcp-watermark.image?)
#### 配置文件的 program 指向谁，相当于启动调试哪个 Nodejs 文件
```diff
// .vscode/launch.json
+{
+  // 使用 IntelliSense 了解相关属性。 
+  // 悬停以查看现有属性的描述。
+  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
+  "version": "0.2.0",
+  "configurations": [
+    {
+      "type": "node",
+      "request": "launch",
+      "name": "启动程序",
+      "skipFiles": [
+        "<node_internals>/**"
+      ],
+      "program": "${workspaceFolder}/debugger.js"
+    }
+  ]
+}
```

## 问题来了
调试 Nodejs 文件我会了，但是命令行工具是启动脚本啊， <span style="color: #ff502c;background-color: #fff5f5">bin脚本</span> 该怎么调试呢？

我教给大家一种万能的方法，不管你的项目结构多复杂，有多少packages，这样调试 bin脚本，就非常简单

#### 在我们的 debugger文件夹下创建bin脚本
```
pnpm init
```

```diff
// package.json
  "bin": {
+    "debugger": "./bin/debugger.js"
  },
```
```ts
// bin/debugger.js
#!/usr/bin/env node
const yang = 'yang'
const yangyang = yang + 'yang'
console.log(yangyang + 'yang');
```
验证bin脚本成功
```
npm link
debugger
// yangyangynag
```

#### 进入配置文件
```diff
// .vscode/launch.json
{
  // 使用 IntelliSense 了解相关属性。 
  // 悬停以查看现有属性的描述。
  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "启动程序",
      "skipFiles": [
        "<node_internals>/**"
      ],
-      "program": "${workspaceFolder}/debugger.js"
+      "program": "${workspaceFolder}/bin/debugger.js"
    }
  ]
}
```
其实就是把 NodeJS文件 的入口指定成我们的 bin脚本 的入口，是不是有点过于简单了

因为 <span style="color: #ff502c;background-color: #fff5f5">npm run xxx</span> 的<span style="color: #ff502c;background-color: #fff5f5">本质</span>就是执行 <span style="color: #ff502c;background-color: #fff5f5">Node环境</span>的bin脚本 而 Node环境的 bin脚本 就是<span style="color: #ff502c;background-color: #fff5f5">执行Nodejs代码</span>
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd9a2387303844358fffa6c5ca4f9fe8~tplv-k3u1fbpfcp-watermark.image?)
## 3.什么是sourcemap？调试中为什么需要sourcemap？
1.通常我们写好代码之后都会在<span style="color: #ff502c;background-color: #fff5f5">打包</span>的时候进行<span style="color: #ff502c;background-color: #fff5f5">压缩</span>、<span style="color: #ff502c;background-color: #fff5f5">polyfill</span>等一系列优化处理

2.为了让使用者得到良好的<span style="color: #ff502c;background-color: #fff5f5">类型支持</span>，现代大多数类库都会选择用 <span style="color: #ff502c;background-color: #fff5f5">TypeScript</span> 进行开发，ts到js需要编译处理
### 什么是SourceMap？
<span style="color: #ff502c;background-color: #fff5f5">SourceMap</span> 是一个信息文件，里面存储了代码打包编译转换后的位置信息
通过开启sourcemap之后生成的xxx.map文件，你就可以知道<br>
- 打包之后的哪一个文件对应打包之前的哪一个文件

当然，它能清晰的对应到具体的<span style="color: #ff502c;background-color: #fff5f5">代码行数</span>

> no say, let's code
这里在前几小节已经详解过了，不过多赘述
```
tsc --init
```
```diff
// tsconfig.json
+     "declaration": true,     //开启 ts声明文件 -- d.ts
```
```ts
// src/index.ts
export const yang: string = 'yang'

const yangyang = yang + 'yang'

console.log(yangyang + 'yang');
```
```
npm i father
```
```diff
// .fatherrc.ts
import { defineConfig } from 'father'
export default defineConfig({
  cjs: {
    output: "dist",
+   sourcemap: true   // 开启编译时sourcemap
  }
})
```
```diff
// package.json
  "scripts": {
+    "dev": "father dev",
+    "build": "father build"
  },
```
```
npm run dev
```

成功生成 <span style="color: #ff502c;background-color: #fff5f5">产物</span> 和 <span style="color: #ff502c;background-color: #fff5f5">.map</span>文件
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e1d898985bb44ac822be117c46046ec~tplv-k3u1fbpfcp-watermark.image?)

我们来分别看下生成的 <span style="color: #ff502c;background-color: #fff5f5">产物</span> 和 <span style="color: #ff502c;background-color: #fff5f5">sourcemap文件</span>
```js
// 产物文件：dist/index.js
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  yang: () => yang
});
module.exports = __toCommonJS(src_exports);
var yang = "yang";
var yangyang = yang + "yang";
console.log(yangyang + "yang");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  yang
});
//# sourceMappingURL=index.js.map
```
```js
// sourcemap文件：dist/index.js.map
{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["export const yang: string = 'yang'\n\nconst yangyang = yang + 'yang'\n\nconsole.log(yangyang + 'yang');\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO,IAAM,OAAe;AAE5B,IAAM,WAAW,OAAO;AAExB,QAAQ,IAAI,WAAW,MAAM;",
  "names": []
}
```
产物中指明了对应的 <span style="color: #ff502c;background-color: #fff5f5">sourcemap </span>文件
> sourceMappingURL=index.js.map
sourcemap 文件中也指明了对应的<span style="color: #ff502c;background-color: #fff5f5">源产物</span>和<span style="color: #ff502c;background-color: #fff5f5">sourcesContent</span>

### 接下来，我们来利用 sourcemap<span style="color: #ff502c;background-color: #fff5f5">打断点调试</span>

```diff
// bin/debugger.js
#!/usr/bin/env node
+ require('../dist/index.js')
- const yang = 'yang'
- const yangyang = yang + 'yang'
- console.log(yangyang + 'yang');
```

在 <span style="color: #ff502c;background-color: #fff5f5">src/index.ts</span> 里面打断点

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbb302982f65474eb3667dd997184e28~tplv-k3u1fbpfcp-watermark.image?)
调试配置文件的 **<span style="color: #ff502c;background-color: #fff5f5">program</span>** 字段 还是指向 <span style="color: #ff502c;background-color: #fff5f5">bin/debugger.js</span>
```json
// .vscode/launch.json
{
  // 使用 IntelliSense 了解相关属性。 
  // 悬停以查看现有属性的描述。
  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "启动程序",
      "skipFiles": [
        "<node_internals>/**"
      ],
     "program": "${workspaceFolder}/bin/debugger.js"
    }
  ]
}
```

现在我们就可以 **<span style="color: #ff502c;background-color: #fff5f5">直接调试源代码</span>** 而不是<span style="color: #ff502c;background-color: #fff5f5">打包压缩编译</span>之后<span style="color: #ff502c;background-color: #fff5f5">看不懂</span>的代码了

他会在执行编译之后的产物代码的时候，自动定位到编译之前的代码，这样我们就可以调试 **<span style="color: #ff502c;background-color: #fff5f5">源码</span>** 了！
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3307dcbdbc74a5fa58f2f13fc086d47~tplv-k3u1fbpfcp-watermark.image?)
### 所以你可以回答我们为什么需要sourcemap吗?
如果你能看懂<span style="color: #ff502c;background-color: #fff5f5">编译</span>、<span style="color: #ff502c;background-color: #fff5f5">polyfill</span>、<span style="color: #ff502c;background-color: #fff5f5">压缩</span>等一系列操作之后之后生成的产物代码，就不需要 sourcmap 了(嘿嘿

## 4.实战：调试 **<span style="color: #ff502c;background-color: #fff5f5">Umi</span>** 源代码
我们来看 [Umi](https://github.com/umijs/umi) 的源码

Umi 这个仓库采用 pnpm 的 <span style="color: #ff502c;background-color: #fff5f5">Monorepo</span> 管理

我们随便进入一个其中一个 package，可以发现也是使用 **<span style="color: #ff502c;background-color: #fff5f5">father</span>** 进行<span style="color: #ff502c;background-color: #fff5f5">编译</span>
### 1. clone [Umi](https://github.com/umijs/umi) 源码到本地
```
// 终端
git clone https://github.com/umijs/umi.git
code umi
```
### 2.寻找 bin 脚本入口
tips：可以在某个项目中安装 Umi，然后查看 <span style="color: #ff502c;background-color: #fff5f5">node_modules</span> 下 umi 中的 bin 命令

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10aad6b511f94fc2930cd8445b1db364~tplv-k3u1fbpfcp-watermark.image?)

然后我们就可以在 Umi<span style="color: #ff502c;background-color: #fff5f5">源码</span> 中去定位入口 <span style="color: #ff502c;background-color: #fff5f5">bin</span> 脚本的位置了<br>
-- packages/umi/bin/umi.js
```js
// packages/umi/bin/umi.js
#!/usr/bin/env node

// disable since it's conflicted with typescript cjs + dynamic import
// require('v8-compile-cache');

// patch console for debug
// ref: https://remysharp.com/2014/05/23/where-is-that-console-log
if (process.env.DEBUG_CONSOLE) {
  ['log', 'warn', 'error'].forEach((method) => {
    const old = console[method];
    console[method] = function () {
      let stack = new Error().stack.split(/\n/);
      // Chrome includes a single "Error" line, FF doesn't.
      if (stack[0].indexOf('Error') === 0) {
        stack = stack.slice(1);
      }
      const args = [].slice.apply(arguments).concat([stack[1].trim()]);
      return old.apply(console, args);
    };
  });
}

require('../dist/cli/cli')
  .run()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  });
```
### 3.安装依赖、生成 bin 脚本需要的 dist 目录
```
// 根目录
pnpm i 
npm run build  //执行了 turo run build
```
### 4.设置调试配置
注意：这里新增一个 “stopOnEntry”: true，作用是会在入口文件第一行打断点，不需要我们亲手去打，可以从入口开始调试
```json
// .vscode/launch.json
{
  // 使用 IntelliSense 了解相关属性。 
  // 悬停以查看现有属性的描述。
  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "启动程序",
      "program": "${workspaceFolder}/packages/umi/bin/umi.js",
      "args": ["dev"],
      "stopOnEntry": true
    }
  ]
}

```
### 5.出现问题
这里我们忘记了一个关键因素，sourcemap
我这里准备去他的 <span style="color: #ff502c;background-color: #fff5f5">.fatherrc.ts 配置文件</span>开启一下sourcemap

结果发现他现在father版本是<span style="color: #ff502c;background-color: #fff5f5">3.x</span>，<span style="color: #ff502c;background-color: #fff5f5">不支持</span>开启<span style="color: #ff502c;background-color: #fff5f5">sourcemap</span>
## 5.基于调试中的问题，给 Umi 提个pr
先提个<span style="color: #ff502c;background-color: #fff5f5">issue</span>：https://github.com/umijs/umi/issues/9876 <br>
<span style="color: #ff502c;background-color: #fff5f5">pr</span>--升级father版本到4.x支持<span style="color: #ff502c;background-color: #fff5f5">sourcemap</span>：https://github.com/umijs/umi/pull/9877

到现在为止，该 pr 已经<span style="color: #ff502c;background-color: #fff5f5">合并</span>

### 这样，我们就可以开始调试 Umi <span style="color: #ff502c;background-color: #fff5f5">源代码</span>了！而且每次都会进入源码ts文件中 ✅
